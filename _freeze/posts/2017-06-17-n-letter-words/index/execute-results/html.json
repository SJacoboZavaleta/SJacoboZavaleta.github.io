{
  "hash": "dfc9f7916572937f4ad9c5ebd83fc210",
  "result": {
    "markdown": "---\ntitle: \"n_letter_words and a personal (publicly available) package\"\ndescription: |\n  How I created a handy function and a personal package\ndate: 2017-06-17\nsite-url: https://ellakaye.rbind.io/\nimage: EMK-hex.png\nimage-alt: |\n  A hexagon with a bright pink outline. Inside it, the letters E, M and K in the \n  same bright pink, on a white background\ncategories:\n  - R\n  - package development\n#twitter-card: \n# uncomment lines below for different title and description to post\n#  title: |\n#  description: |\n# uncomment for different image to post\n#  image: |\n#  image-alt: |\n#  defaults to 500 x 500 summary: uncomment lines below for large card\n#  image-width: 600 \n#  image-height: 314\n#  card-style: summary_large_image \ndraft: false\n---\n\n\nThere's a little R function that I wrote and packaged up to generate a vector or data frame of words of a given length. I find it useful in a wide variety of contexts and thought other might too. To kick off my new blog, here's a post about it.\n\nThe function, `n_letter_words`, came about because I wanted to be able to generate row and column names for a large matrix - didn't matter what they were, as long as they were unique. Since I was in the habit of using the built-in `LETTERS` vector to do this for small matrices, I naturally thought of using combinations of letters to do this in a larger case. In figuring out how to do this, as is so often the case, it was [stackoverflow](https://stackoverflow.com/questions/11388359/unique-combination-of-all-elements-from-two-or-more-vectors) to the rescue. There, I learnt about `expand.grid` and could then use some tidyverse tools to get the vector I was after:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nout <- expand.grid(LETTERS, LETTERS) %>%\n  as_tibble() %>%\n  unite(word, 1:2, sep = \"\") %>%\n  pull()\nc(head(out), tail(out))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"AA\" \"BA\" \"CA\" \"DA\" \"EA\" \"FA\" \"UZ\" \"VZ\" \"WZ\" \"XZ\" \"YZ\" \"ZZ\"\n```\n:::\n:::\n\n\nSorted! At least I thought so, until, a couple of months later, when I wanted to generate names for a 1000\\*1000 matrix, and realised both that I'd forgotten the `expand.grid` trick, and once I'd re-found the stackoverflow post, that it didn't give me enough words. That was enough to make it worth writing a function, taking `n` as an argument, that gives all 'words' of length $n$. \n\nWriting functions always makes me think of what other arguments might be useful. What if we want something between the 676 two-letter words and 17,576 three-letter words (or the 456,976 four-letter words, etc)? Hence the argument `num_letters`, which can be set between 1 and 26, and results in a total of `num_letters`$^n$ words. By default, the function returns a `tibble`, but setting `as_vector = TRUE` does what you'd expect. And I threw in a `case` argument too.\n\nNow that I had my function, what to do with it? I remembered articles I'd read about the usefulness of [making](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/) and [sharing]((https://hilaryparker.com/2013/04/03/personal-r-packages/)) a personal package. Now seemed like the time to do that myself. \n\nSo, [here](https://github.com/EllaKaye/EMK) is my personal package, `EMK`. If you think that `n_letter_words` might be of use to you, then feel free to install!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"EllaKaye/EMK\")\n```\n:::\n\n\nSome examples of `n_letter_words`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(EMK)\n\nn_letter_words(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 676 × 1\n   word \n   <chr>\n 1 AA   \n 2 BA   \n 3 CA   \n 4 DA   \n 5 EA   \n 6 FA   \n 7 GA   \n 8 HA   \n 9 IA   \n10 JA   \n# … with 666 more rows\n```\n:::\n\n```{.r .cell-code}\nsome_three_letter_words <- n_letter_words(\n  n = 3, \n  num_letters = 10, \n  case = \"lower\", \n  as_vector = TRUE\n)\n\nc(head(some_three_letter_words), tail(some_three_letter_words))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"aaa\" \"baa\" \"caa\" \"daa\" \"eaa\" \"faa\" \"ejj\" \"fjj\" \"gjj\" \"hjj\" \"ijj\" \"jjj\"\n```\n:::\n\n```{.r .cell-code}\nlength(some_three_letter_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\nFor now, my personal package has only this one function, but watch this space! No doubt I'll be adding more that I find useful. Perhaps, you'll find them useful too.\n\nIncidentally, none of the above would have happened if I'd just thought, for my test matrix `A`, to set `dimnames(A) <- list(1:nrow(A), 1:ncol(A))`!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}